# I/Oについての補足資料
I/O周りのシミュレータでの時間予測に必要な情報

## server.pyの仕様
CPUにおけるI/OはUART通信で行われている。パソコン側のプログラムserver.pyは以下のようなフローで動作する。
1. CPUからの0x99の信号を待機する
2. 0x99を受け取ったら、プログラムを送信開始すると同時に時間計測を開始する
3. プログラムの送信が完了したら0xaaの信号を待機する
4. 0xaaを受け取ったら、SLDファイルの送信を開始する
5. SLDを送り終わったら、PPMの受信を行い、受信完了時刻までを経過時間として計測する

UART通信の速度はbaudrateを用いて表す。baudrateをBとするとき、転送速度(bytes per second)はB/10である。現在baudrate=2304000である。

## コアの仕様
### 0x99 ~ プログラム受信
コアは実行開始後すぐに0x99を送信し、プログラム受信を行う。この段階ではまだコアは動作していない(nop命令を繰り返し実行している)。

### プログラム受信完了 ~ SLD受信
プログラムは受け取ったバイト数をカウントしながら受信し、指定バイト数に達したら、0xaaを送信しデータ受信体制に入るとともに、コアの実行をpc=0から開始する。SLDの受信はコアの実行とは独立して行われ、受信したデータは4バイトずつ一まとまりにされ、input controllerによって順次バッファに書き込まれる。コアで`in`命令が実行されたとき、もしバッファが空でなければ先頭から読み出し、空なら次の4バイトがバッファに書き込まれるのをストールして待機する。

### PPMの送信
コアで`out`命令が実行されたとき、直接は送信せずoutput bufferにその1バイトが書き込まれる。output controllerはコアとは独立して動作し、output bufferが空でない間そこに書いてあるデータを先頭から1バイトずつ読み出して送信し続ける。

## コアの実装
コア、メモリ、I/O関連のモジュールはすべてio_core_controllerの中に置かれており、このモジュールにおいて、適切なタイミングで0xaaを送信するなどの制御を行っている。io_core_controllerは以下の3つの状態をもつ有限状態機械である。
- INIT: 実行開始前。0x99を送信してすぐPROG_RECVに遷移する
- PROG_RECV: プログラム受信中。受信完了したら0xaaを送信してEXECUTEに遷移する
- EXECUTE: コア実行中。データの受信・送信もこの状態で行う

io_core_controllerの内部は以下のようなモジュール構造になっている。
```
io_core_controller
├── core
├── inst_mem
├── data_mem
├── bram
├── input_controller
│   └── uart_buf_rx
│       └── uart_rx
└── output_controller
    └── uart_tx
```

input_controllerは受信のフェーズによって書き込む先を制御する必要がある。そこで、input controllerもまたFSMになっており、状態に応じて書き込む先を切り替えるようになっている。状態は
- PROG_SIZE: server.pyがプログラムの先頭に付加するプログラムサイズを読み取る
- DATA_SEC_SIZE: プログラムの先頭4バイトに記されたdata sectionのサイズを読み取る
- TEXT_SEC_SIZE: プログラムの次の4バイトに記されたtext sectionのサイズを読み取る
- PROG_DATA_SEC: データセクションを受け取りBRAMに書き込む
- PROG_TEXT_SEC: テキストセクションを受け取り命令メモリに書き込む
- DATA: SLDを受け取りバッファに書き込む
の順に遷移する。